{"version":3,"sources":["webpack:///webpack/universalModuleDefinition?5ca6","wildcard-store/wildcard-store.min.js","webpack:///webpack/bootstrap 2bd00a29ec0bc8afd80e?657d","webpack:///./src/Store.js?6192","webpack:///./src/Record.js?b800","webpack:///./src/doPathsMatch.js?e185"],"names":["root","factory","exports","module","define","amd","this","modules","__webpack_require__","moduleId","installedModules","id","loaded","call","m","c","p","Store","settings","_records","_paths","_settings","Record","doPathsMatch","DEFAULT_SETTINGS","delimeter","prefix","prototype","constructor","get","pattern","path","pathArr","pathRecords","record","paths","matchedValues","patternArr","split","validatePath","i","length","substr","j","active","push","use","splice","del","set","value","uses","getOrCreatePath","keyIndex","arguments","is","undefined","indexOf","records","numberOfWildcards","search","Error","Infinity","doPathBeginningsMatch","path1","path2","minLength","Math","min","reversedPath1","Array","reversedPath2"],"mappings":"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","file":"wildcard-store.min.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"wildcard-store\"] = factory();\n\telse\n\t\troot[\"wildcard-store\"] = factory();\n})(this, function() {\nreturn \n\n\n// WEBPACK FOOTER //\n// webpack/universalModuleDefinition","(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"wildcard-store\"] = factory();\n\telse\n\t\troot[\"wildcard-store\"] = factory();\n})(this, function() {\nreturn /******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\texports: {},\n/******/ \t\t\tid: moduleId,\n/******/ \t\t\tloaded: false\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.loaded = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(0);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tvar Record = __webpack_require__(1);\n\tvar doPathsMatch = __webpack_require__(2);\n\t\n\t\n\tvar DEFAULT_SETTINGS = {\n\t  delimeter: '.',\n\t  prefix: '~'\n\t};\n\t\n\t\n\tfunction Store(settings) {\n\t  this._records = {};\n\t  this._paths = [];\n\t  this._settings = settings || {};\n\t}\n\t\n\tmodule.exports = Store;\n\tStore.prototype.constructor = Store;\n\t\n\t\n\tStore.prototype.get = function get(pattern) {\n\t  var delimeter = this._settings.delimeter || DEFAULT_SETTINGS.delimeter;\n\t  var prefix = this._settings.prefix || DEFAULT_SETTINGS.prefix;\n\t  var paths = this._paths;\n\t  var matchedValues = [];\n\t  var patternArr = pattern.split(delimeter);\n\t  var path, pathArr, pathRecords, record;\n\t\n\t  this.validatePath(patternArr);\n\t\n\t  for (var i = 0; i < paths.length; i++) {\n\t    path = paths[i];\n\t    pathArr = path.substr(prefix.length).split(delimeter);\n\t\n\t    if (path === pattern || doPathsMatch(patternArr, pathArr)) {\n\t      pathRecords = this._records[path];\n\t\n\t      for (var j = 0; j < pathRecords.length; j++) {\n\t        record = pathRecords[j];\n\t\n\t        if (record.active) {\n\t          matchedValues.push(record.use());\n\t        }\n\t\n\t        if (!record.active) {\n\t          pathRecords.splice(j, 1);\n\t          j--;\n\t        }\n\t      }\n\t\n\t      if (pathRecords.length === 0) {\n\t        this.del(path.substr(1));\n\t      }\n\t    }\n\t  }\n\t\n\t  return matchedValues;\n\t};\n\t\n\t\n\tStore.prototype.set = function set(path, value, uses) {\n\t  var record = new Record(value, uses);\n\t  this.getOrCreatePath(path).push(record);\n\t};\n\t\n\t\n\tStore.prototype.del = function del(path, value) {\n\t  var prefix = this._settings.prefix || DEFAULT_SETTINGS.prefix;\n\t  path = prefix + path;\n\t\n\t  var pathRecords = this._records[path];\n\t  var keyIndex;\n\t\n\t  if (!pathRecords) {\n\t    return;\n\t  }\n\t\n\t  if (arguments.length === 2) {\n\t    for (var i = 0; i < pathRecords.length; i++) {\n\t      if (pathRecords[i].is(value)) {\n\t        pathRecords[i].active = false;\n\t        pathRecords.splice(i, 1);\n\t        i--;\n\t      }\n\t    }\n\t  }\n\t\n\t  if (arguments.length === 1 || pathRecords.length === 0) {\n\t    this._records[path] = undefined;\n\t    keyIndex = this._paths.indexOf(path);\n\t\n\t    if (keyIndex !== -1) {\n\t      this._paths.splice(keyIndex, 1);\n\t    }\n\t  }\n\t};\n\t\n\t\n\tStore.prototype.getOrCreatePath = function getOrCreatePath(path) {\n\t  var delimeter = this._settings.delimeter || DEFAULT_SETTINGS.delimeter;\n\t  var prefix = this._settings.prefix || DEFAULT_SETTINGS.prefix;\n\t  var pathArr = path.split(delimeter);\n\t\n\t  this.validatePath(pathArr);\n\t\n\t  path = prefix + path;\n\t  var records = this._records[path];\n\t\n\t  if (!records) {\n\t    this._paths.push(path);\n\t    records = this._records[path] = [];\n\t  }\n\t\n\t  return records;\n\t};\n\t\n\t\n\tStore.prototype.validatePath = function validatePath(pathArr) {\n\t  var numberOfWildcards = 0;\n\t\n\t  for (var i = 0; i < pathArr.length; i++) {\n\t    if (pathArr[i].length === 0 || pathArr[i].search(/^\\s*$/) !== -1) {\n\t      throw new Error('Path must not contain empty or whitespace-only fragments');\n\t    }\n\t\n\t    if (pathArr[i] === '*' || pathArr[i] === '**') {\n\t      numberOfWildcards++;\n\t\n\t      if (numberOfWildcards > 1) {\n\t        throw new Error('Path must not contain more than one wildcard');\n\t      }\n\t    }\n\t  }\n\t};\n\n\n/***/ },\n/* 1 */\n/***/ function(module, exports) {\n\n\t'use strict';\n\t\n\t\n\tfunction Record(value, uses) {\n\t  if (!value) {\n\t    throw new Error('Can\\'t create a record without a value');\n\t  }\n\t\n\t  this.active = true;\n\t  this.uses = uses || Infinity;\n\t  this.value = value;\n\t}\n\t\n\tmodule.exports = Record;\n\tRecord.prototype.constructor = Record;\n\t\n\t\n\tRecord.prototype.is = function is(record) {\n\t  return (record === this || record === this.value);\n\t};\n\t\n\tRecord.prototype.use = function use() {\n\t  if (!this.active || this.uses < 1) {\n\t    throw new Error('Can\\'t use an inactive record');\n\t  }\n\t\n\t  this.uses--;\n\t  this.active = (this.uses >= 1);\n\t\n\t  return this.value;\n\t};\n\n\n/***/ },\n/* 2 */\n/***/ function(module, exports) {\n\n\t'use strict';\n\t\n\t\n\tmodule.exports = function doPathsMatch(path1, path2) {\n\t  if (path1[0] === '**' && path2[path2.length] === '**' ||\n\t      path2[0] === '**' && path1[path1.length] === '**') {\n\t    return true;\n\t  }\n\t\n\t  var minLength = Math.min(path1.length, path2.length);\n\t\n\t  if (!doPathBeginningsMatch(path1, path2, minLength)) {\n\t    return false;\n\t  }\n\t\n\t  var reversedPath1 = new Array(minLength);\n\t  var reversedPath2 = new Array(minLength);\n\t\n\t  for (var i = 0; i < minLength; i++) {\n\t    reversedPath1[i] = path1[path1.length - i - 1];\n\t    reversedPath2[i] = path2[path2.length - i - 1];\n\t  }\n\t\n\t  if (!doPathBeginningsMatch(reversedPath1, reversedPath2, minLength)) {\n\t    return false;\n\t  }\n\t\n\t  return true;\n\t};\n\t\n\t\n\tfunction doPathBeginningsMatch(path1, path2, minLength) {\n\t  for (var i = 0; i < minLength; i++) {\n\t    if (path1[i] === '**' || path2[i] === '**') {\n\t      return true;\n\t    }\n\t\n\t    if (path1[i] !== path2[i] && path1[i] !== '*' && path2[i] !== '*') {\n\t      return false;\n\t    }\n\t  }\n\t\n\t  return (minLength === path1.length && minLength === path2.length);\n\t}\n\n\n/***/ }\n/******/ ])\n});\n;\n\n\n// WEBPACK FOOTER //\n// wildcard-store.min.js"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\texports: {},\n \t\t\tid: moduleId,\n \t\t\tloaded: false\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.loaded = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(0);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap 2bd00a29ec0bc8afd80e","'use strict';\n\nvar Record = require('./Record');\nvar doPathsMatch = require('./doPathsMatch');\n\n\nvar DEFAULT_SETTINGS = {\n  delimeter: '.',\n  prefix: '~'\n};\n\n\nfunction Store(settings) {\n  this._records = {};\n  this._paths = [];\n  this._settings = settings || {};\n}\n\nmodule.exports = Store;\nStore.prototype.constructor = Store;\n\n\nStore.prototype.get = function get(pattern) {\n  var delimeter = this._settings.delimeter || DEFAULT_SETTINGS.delimeter;\n  var prefix = this._settings.prefix || DEFAULT_SETTINGS.prefix;\n  var paths = this._paths;\n  var matchedValues = [];\n  var patternArr = pattern.split(delimeter);\n  var path, pathArr, pathRecords, record;\n\n  this.validatePath(patternArr);\n\n  for (var i = 0; i < paths.length; i++) {\n    path = paths[i];\n    pathArr = path.substr(prefix.length).split(delimeter);\n\n    if (path === pattern || doPathsMatch(patternArr, pathArr)) {\n      pathRecords = this._records[path];\n\n      for (var j = 0; j < pathRecords.length; j++) {\n        record = pathRecords[j];\n\n        if (record.active) {\n          matchedValues.push(record.use());\n        }\n\n        if (!record.active) {\n          pathRecords.splice(j, 1);\n          j--;\n        }\n      }\n\n      if (pathRecords.length === 0) {\n        this.del(path.substr(1));\n      }\n    }\n  }\n\n  return matchedValues;\n};\n\n\nStore.prototype.set = function set(path, value, uses) {\n  var record = new Record(value, uses);\n  this.getOrCreatePath(path).push(record);\n};\n\n\nStore.prototype.del = function del(path, value) {\n  var prefix = this._settings.prefix || DEFAULT_SETTINGS.prefix;\n  path = prefix + path;\n\n  var pathRecords = this._records[path];\n  var keyIndex;\n\n  if (!pathRecords) {\n    return;\n  }\n\n  if (arguments.length === 2) {\n    for (var i = 0; i < pathRecords.length; i++) {\n      if (pathRecords[i].is(value)) {\n        pathRecords[i].active = false;\n        pathRecords.splice(i, 1);\n        i--;\n      }\n    }\n  }\n\n  if (arguments.length === 1 || pathRecords.length === 0) {\n    this._records[path] = undefined;\n    keyIndex = this._paths.indexOf(path);\n\n    if (keyIndex !== -1) {\n      this._paths.splice(keyIndex, 1);\n    }\n  }\n};\n\n\nStore.prototype.getOrCreatePath = function getOrCreatePath(path) {\n  var delimeter = this._settings.delimeter || DEFAULT_SETTINGS.delimeter;\n  var prefix = this._settings.prefix || DEFAULT_SETTINGS.prefix;\n  var pathArr = path.split(delimeter);\n\n  this.validatePath(pathArr);\n\n  path = prefix + path;\n  var records = this._records[path];\n\n  if (!records) {\n    this._paths.push(path);\n    records = this._records[path] = [];\n  }\n\n  return records;\n};\n\n\nStore.prototype.validatePath = function validatePath(pathArr) {\n  var numberOfWildcards = 0;\n\n  for (var i = 0; i < pathArr.length; i++) {\n    if (pathArr[i].length === 0 || pathArr[i].search(/^\\s*$/) !== -1) {\n      throw new Error('Path must not contain empty or whitespace-only fragments');\n    }\n\n    if (pathArr[i] === '*' || pathArr[i] === '**') {\n      numberOfWildcards++;\n\n      if (numberOfWildcards > 1) {\n        throw new Error('Path must not contain more than one wildcard');\n      }\n    }\n  }\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/Store.js\n// module id = 0\n// module chunks = 0 1","'use strict';\n\n\nfunction Record(value, uses) {\n  if (!value) {\n    throw new Error('Can\\'t create a record without a value');\n  }\n\n  this.active = true;\n  this.uses = uses || Infinity;\n  this.value = value;\n}\n\nmodule.exports = Record;\nRecord.prototype.constructor = Record;\n\n\nRecord.prototype.is = function is(record) {\n  return (record === this || record === this.value);\n};\n\nRecord.prototype.use = function use() {\n  if (!this.active || this.uses < 1) {\n    throw new Error('Can\\'t use an inactive record');\n  }\n\n  this.uses--;\n  this.active = (this.uses >= 1);\n\n  return this.value;\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/Record.js\n// module id = 1\n// module chunks = 0 1","'use strict';\n\n\nmodule.exports = function doPathsMatch(path1, path2) {\n  if (path1[0] === '**' && path2[path2.length] === '**' ||\n      path2[0] === '**' && path1[path1.length] === '**') {\n    return true;\n  }\n\n  var minLength = Math.min(path1.length, path2.length);\n\n  if (!doPathBeginningsMatch(path1, path2, minLength)) {\n    return false;\n  }\n\n  var reversedPath1 = new Array(minLength);\n  var reversedPath2 = new Array(minLength);\n\n  for (var i = 0; i < minLength; i++) {\n    reversedPath1[i] = path1[path1.length - i - 1];\n    reversedPath2[i] = path2[path2.length - i - 1];\n  }\n\n  if (!doPathBeginningsMatch(reversedPath1, reversedPath2, minLength)) {\n    return false;\n  }\n\n  return true;\n};\n\n\nfunction doPathBeginningsMatch(path1, path2, minLength) {\n  for (var i = 0; i < minLength; i++) {\n    if (path1[i] === '**' || path2[i] === '**') {\n      return true;\n    }\n\n    if (path1[i] !== path2[i] && path1[i] !== '*' && path2[i] !== '*') {\n      return false;\n    }\n  }\n\n  return (minLength === path1.length && minLength === path2.length);\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/doPathsMatch.js\n// module id = 2\n// module chunks = 0 1"],"sourceRoot":""}